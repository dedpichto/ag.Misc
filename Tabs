public static class TabManager
{
    private static readonly Dictionary<FrameworkElement, string> _controlRegistry = new();
    
    public static readonly DependencyProperty ControlNameProperty =
        DependencyProperty.RegisterAttached("ControlName", typeof(string), typeof(TabManager),
            new PropertyMetadata(OnControlNameChanged));
    
    public static readonly DependencyProperty TabManagerProperty =
        DependencyProperty.RegisterAttached("TabManager", typeof(ITabManager), typeof(TabManager),
            new PropertyMetadata(OnTabManagerChanged));
    
    public static void SetControlName(DependencyObject obj, string value)
        => obj.SetValue(ControlNameProperty, value);
    
    public static string GetControlName(DependencyObject obj)
        => (string)obj.GetValue(ControlNameProperty);
    
    public static void SetTabManager(DependencyObject obj, ITabManager value)
        => obj.SetValue(TabManagerProperty, value);
    
    public static ITabManager GetTabManager(DependencyObject obj)
        => (ITabManager)obj.GetValue(TabManagerProperty);
    
    private static void OnControlNameChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is FrameworkElement element && e.NewValue is string controlName)
        {
            _controlRegistry[element] = controlName;
            
            // Try to find TabManager in the visual tree
            var tabManager = FindTabManager(element);
            if (tabManager != null)
            {
                UpdateTabProperties(element, tabManager, controlName);
            }
            else
            {
                // Wait for Loaded event to find TabManager
                element.Loaded += OnElementLoaded;
            }
        }
    }
    
    private static void OnElementLoaded(object sender, RoutedEventArgs e)
    {
        if (sender is FrameworkElement element)
        {
            element.Loaded -= OnElementLoaded;
            
            if (_controlRegistry.TryGetValue(element, out string controlName))
            {
                var tabManager = FindTabManager(element);
                if (tabManager != null)
                {
                    UpdateTabProperties(element, tabManager, controlName);
                }
            }
        }
    }
    
    private static void OnTabManagerChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is FrameworkElement container)
        {
            if (e.OldValue is ITabManager oldManager)
            {
                oldManager.TabOrderChanged -= (s, args) => OnTabManagerPropertiesChanged(container);
                oldManager.TabStopChanged -= (s, args) => OnTabManagerPropertiesChanged(container);
            }
            
            if (e.NewValue is ITabManager newManager)
            {
                newManager.TabOrderChanged += (s, args) => OnTabManagerPropertiesChanged(container);
                newManager.TabStopChanged += (s, args) => OnTabManagerPropertiesChanged(container);
                
                // Update all child controls that have ControlName set
                UpdateAllChildControls(container, newManager);
            }
        }
    }
    
    private static void OnTabManagerPropertiesChanged(FrameworkElement container)
    {
        var tabManager = GetTabManager(container);
        if (tabManager != null)
        {
            UpdateAllChildControls(container, tabManager);
        }
    }
    
    private static void UpdateAllChildControls(DependencyObject parent, ITabManager tabManager)
    {
        int childCount = VisualTreeHelper.GetChildrenCount(parent);
        for (int i = 0; i < childCount; i++)
        {
            var child = VisualTreeHelper.GetChild(parent, i);
            
            if (child is FrameworkElement element && _controlRegistry.TryGetValue(element, out string controlName))
            {
                UpdateTabProperties(element, tabManager, controlName);
            }
            
            // Recursively process children
            UpdateAllChildControls(child, tabManager);
        }
    }
    
    private static ITabManager FindTabManager(DependencyObject element)
    {
        DependencyObject current = element;
        while (current != null)
        {
            var tabManager = GetTabManager(current);
            if (tabManager != null)
                return tabManager;
            
            current = VisualTreeHelper.GetParent(current);
        }
        return null;
    }
    
    private static void UpdateTabProperties(FrameworkElement element, ITabManager tabManager, string controlName)
    {
        // Update TabIndex
        var tabIndex = tabManager.GetTabIndex(controlName);
        element.SetCurrentValue(Control.TabIndexProperty, tabIndex);
        
        // Update IsTabStop
        var isTabStop = tabManager.GetIsTabStop(controlName);
        if(isTabStop.HasValue)
            element.SetCurrentValue(Control.IsTabStopProperty, isTabStop.Value);
    }
}

public interface ITabManager
{
    event EventHandler TabOrderChanged;
    event EventHandler TabStopChanged;
    
    int GetTabIndex(string controlName);
    bool? GetIsTabStop(string controlName);
    
    void SetTabOrder(params string[] controlNames);
    void SetTabStops(Dictionary<string, bool> tabStops);
    void EnableTabStop(params string[] controlNames);
    void DisableTabStop(params string[] controlNames);
}


/////////////////////////////////////////////////


public class FormViewModel : INotifyPropertyChanged, ITabManager
{
    private Dictionary<string, int> _tabIndices = new();
    private Dictionary<string, bool> _tabStops = new();
    
    public event EventHandler TabOrderChanged;
    public event EventHandler TabStopChanged;
    
    public FormViewModel()
    {
        InitializeDefaults();
    }
    
    private void InitializeDefaults()
    {
        // Set default tab stops - most controls are tabbable by default
        var allControls = new[] { "FirstName", "LastName", "Email", "Phone", "Address", "City", "State", "Zip", "Comments" };
        foreach (var control in allControls)
        {
            _tabStops[control] = true;
        }
        
        SetNormalTabOrder();
    }
    
    public int GetTabIndex(string controlName)
    {
        return _tabIndices.TryGetValue(controlName, out int index) ? index : 0;
    }
    
    public bool GetIsTabStop(string controlName)
    {
        return _tabStops.TryGetValue(controlName, out var isTabStop) ? isTabStop : (bool?)null;
    }
    
    public void SetTabOrder(params string[] controlNames)
    {
        _tabIndices.Clear();
        for (int i = 0; i < controlNames.Length; i++)
        {
            _tabIndices[controlNames[i]] = i + 1;
        }
        TabOrderChanged?.Invoke(this, EventArgs.Empty);
    }
    
    public void SetTabStops(Dictionary<string, bool> tabStops)
    {
        foreach (var kvp in tabStops)
        {
            _tabStops[kvp.Key] = kvp.Value;
        }
        TabStopChanged?.Invoke(this, EventArgs.Empty);
    }
    
    public void EnableTabStop(params string[] controlNames)
    {
        foreach (var controlName in controlNames)
        {
            _tabStops[controlName] = true;
        }
        TabStopChanged?.Invoke(this, EventArgs.Empty);
    }
    
    public void DisableTabStop(params string[] controlNames)
    {
        foreach (var controlName in controlNames)
        {
            _tabStops[controlName] = false;
        }
        TabStopChanged?.Invoke(this, EventArgs.Empty);
    }
    
    // Convenience methods for common scenarios
    public void SetNormalTabOrder()
    {
        SetTabOrder("FirstName", "LastName", "Email", "Phone", "Address", "City", "State", "Zip", "Comments");
    }
    
    public void SetReadOnlyMode(bool isReadOnly)
    {
        if (isReadOnly)
        {
            // Disable tab stops for input fields, keep navigation elements
            DisableTabStop("FirstName", "LastName", "Email", "Phone", "Address", "City", "State", "Zip", "Comments");
            EnableTabStop("CloseButton", "PrintButton");
        }
        else
        {
            EnableTabStop("FirstName", "LastName", "Email", "Phone", "Address", "City", "State", "Zip", "Comments");
        }
    }
    
    public void SetQuickEntryMode()
    {
        // Only essential fields are tabbable
        DisableTabStop("Address", "City", "State", "Zip", "Comments");
        EnableTabStop("FirstName", "LastName", "Email", "Phone");
        SetTabOrder("FirstName", "LastName", "Email", "Phone");
    }
}

////////////////////////////////////////////////////


<UserControl local:TabManager.TabManager="{Binding}">
    <Grid>
        <TextBox local:TabManager.ControlName="FirstName" Text="{Binding FirstName}" />
        <TextBox local:TabManager.ControlName="LastName" Text="{Binding LastName}" />
        <TextBox local:TabManager.ControlName="Email" Text="{Binding Email}" />
        <TextBox local:TabManager.ControlName="Phone" Text="{Binding Phone}" />
        <!-- No need to bind IsTabStop - it's handled automatically -->
    </Grid>
</UserControl>


//////////////////////////////////////////////////////////////

// Scenario 1: Form in read-only mode
viewModel.SetReadOnlyMode(true);

// Scenario 2: Quick data entry mode
viewModel.SetQuickEntryMode();

// Scenario 3: Conditional field availability
if (isBusinessCustomer)
{
    viewModel.EnableTabStop("CompanyName", "TaxId");
    viewModel.SetTabOrder("CompanyName", "TaxId", "FirstName", "LastName", "Email");
}
else
{
    viewModel.DisableTabStop("CompanyName", "TaxId");
    viewModel.SetTabOrder("FirstName", "LastName", "Email", "Phone");
}

// Scenario 4: Dynamic form based on user permissions
if (!user.CanEditPersonalInfo)
{
    viewModel.DisableTabStop("FirstName", "LastName", "Email");
}
